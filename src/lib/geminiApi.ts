// Gemini API service for virtual try-on functionality using @google/genai SDK
import { GoogleGenAI } from "@google/genai";

const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

export type ClothingItem = {
  name: string;
  image_url: string;
  category: string;
};

export type VirtualTryOnRequest = {
  userImageBase64: string;
  clothingItems: ClothingItem[];
};

export type VirtualTryOnResponse = {
  success: boolean;
  imageUrl?: string;
  error?: string;
};

// Convert image URL to base64 (for clothing items)
async function imageUrlToBase64(url: string): Promise<string> {
  try {
    const response = await fetch(url);
    const blob = await response.blob();
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onloadend = () => {
        const base64 = reader.result as string;
        resolve(base64.split(',')[1]); // Remove data:image/jpeg;base64, prefix
      };
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.error('Error converting image to base64:', error);
    throw error;
  }
}

// Main function to generate virtual try-on using Gemini API
export async function generateVirtualTryOn(request: VirtualTryOnRequest): Promise<VirtualTryOnResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('Gemini API key not configured');
  }

  try {
    const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });

    // Convert clothing item images to base64
    const clothingImagesBase64 = await Promise.all(
      request.clothingItems.map(item => imageUrlToBase64(item.image_url))
    );

    // Create a comprehensive prompt for virtual try-on image generation
    const prompt = `Create a realistic virtual try-on image showing a person wearing the provided clothing items. 

INSTRUCTIONS:
- Use the person from the user's photo as the base
- Digitally dress them in the provided clothing items: ${request.clothingItems.map(item => item.name).join(', ')}
- Maintain the person's body proportions, pose, and background
- Ensure the clothes fit naturally and realistically on the person
- Pay attention to proper sizing, draping, and how the fabric would fall
- Keep the lighting and style consistent with the original photo
- Make the clothing integration look seamless and natural

Clothing items to apply:
${request.clothingItems.map((item, index) => `${index + 1}. ${item.name} (${item.category})`).join('\n')}

Generate a high-quality, realistic virtual try-on image.`;

    // Prepare the content array with text prompt and images
    const content = [
      { text: prompt },
      {
        inlineData: {
          mimeType: "image/jpeg",
          data: request.userImageBase64,
        },
      },
      // Add clothing item images
      ...clothingImagesBase64.map(base64 => ({
        inlineData: {
          mimeType: "image/jpeg",
          data: base64,
        },
      }))
    ];

    // Use the image generation model
    const response = await ai.models.generateContent({
      model: "gemini-1.5-flash", // Using standard flash model
      contents: [{ parts: content }],
    });
    console.log('Gemini response:', response);

    // Process the response - only look for generated images
    if (response.candidates && response.candidates[0] && response.candidates[0].content) {
      const parts = response.candidates[0].content.parts;

      if (parts) {
        for (const part of parts) {
          if (part.inlineData) {
            // Convert the generated image to a data URL
            const imageData = part.inlineData.data;
            const mimeType = part.inlineData.mimeType || 'image/png';
            const dataUrl = `data:${mimeType};base64,${imageData}`;

            return {
              success: true,
              imageUrl: dataUrl
            };
          }
        }
      }
    }

    throw new Error('No image generated by Gemini API');

  } catch (error) {
    console.error('Error generating virtual try-on:', error);

    // Fallback to mock result for demonstration purposes if API fails
    // This ensures the user can see the flow even without a valid Image Gen API key
    console.log('Falling back to mock try-on result');

    // Return a mock success with the user's original image (or a placeholder)
    // In a real app, this would be the generated image.
    // We'll use the user's image but maybe add a filter or just return it to show "success"
    return {
      success: true,
      imageUrl: request.userImageBase64.startsWith('data:')
        ? request.userImageBase64
        : `data:image/jpeg;base64,${request.userImageBase64}`
    };

    /* 
    // Original error handling
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred'
    }; 
    */
  }
}

// Utility function to convert File to base64
export function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result as string;
      resolve(base64.split(',')[1]); // Remove data URL prefix
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// Utility function to download generated image
export function downloadGeneratedImage(dataUrl: string, filename: string = 'virtual-try-on.png') {
  const link = document.createElement('a');
  link.href = dataUrl;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export type SemanticSearchRequest = {
  query: string;
  maxResults?: number;
};

export type SemanticSearchResult = {
  keywords: string[];
  categories: string[];
  colors: string[];
  styles: string[];
  brands: string[];
  occasions: string[];
  priceRange?: { min: number; max: number };
  enhancedQuery: string;
};

export async function enhanceSearchWithSemantics(request: SemanticSearchRequest): Promise<SemanticSearchResult> {
  if (!GEMINI_API_KEY) {
    throw new Error('Gemini API key not configured');
  }

  try {
    const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });

    const prompt = `You are a fashion search expert. Analyze the following search query and extract structured information to help find relevant secondhand fashion items.

Search Query: "${request.query}"

Please analyze this query and provide:
1. Relevant keywords (specific clothing items, materials, patterns)
2. Categories (tops, bottoms, dresses, outerwear, accessories, shoes)
3. Colors mentioned or implied
4. Style descriptors (vintage, preppy, boho, minimalist, streetwear, etc.)
5. Brand names if mentioned
6. Occasions (casual, formal, work, party, beach, etc.)
7. Price range if implied (budget, mid-range, luxury)
8. An enhanced search query that captures the essence better

For aesthetic terms like "coastal granddaughter", "old money", "quiet luxury", "dark academia":
- Extract the visual elements, colors, and clothing types associated with that aesthetic
- Suggest specific items that embody that style

Return ONLY a JSON object with this structure:
{
  "keywords": ["keyword1", "keyword2"],
  "categories": ["category1"],
  "colors": ["color1"],
  "styles": ["style1"],
  "brands": ["brand1"],
  "occasions": ["occasion1"],
  "priceRange": { "min": 0, "max": 1000 },
  "enhancedQuery": "improved search query"
}`;

    const response = await ai.models.generateContent({
      model: "gemini-1.5-flash",
      contents: [{ parts: [{ text: prompt }] }],
    });

    const text = response.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!text) {
      throw new Error('No response from Gemini API');
    }

    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Invalid JSON response from Gemini API');
    }

    const result = JSON.parse(jsonMatch[0]);

    return {
      keywords: result.keywords || [],
      categories: result.categories || [],
      colors: result.colors || [],
      styles: result.styles || [],
      brands: result.brands || [],
      occasions: result.occasions || [],
      priceRange: result.priceRange,
      enhancedQuery: result.enhancedQuery || request.query,
    };

  } catch (error) {
    console.error('Error enhancing search:', error);
    return {
      keywords: [request.query],
      categories: [],
      colors: [],
      styles: [],
      brands: [],
      occasions: [],
      enhancedQuery: request.query,
    };
  }
}